#pragma once
#include "Lexer.h"
#include <stack>
#include "../CarbonCommonLib/Instruction.h"

namespace Carbon
{
	/// you should be catching this
	class ParserException : public std::logic_error
	{
	public:
		// at which line did the error occure, -1 if unknown
		int Line;
		// position in line at which there was an error, -1 if unknown
		int LinePosition;

		std::string GetMessage() const;

		std::string GetMessageWithLineAndPosition() const;

		explicit ParserException(const std::string& _Message);

		explicit ParserException(const char* _Message);
	};

	// parser
	class Parser : public InstructionReader
	{
	public:

		// parser needs a lexer
		Parser(Lexer& lexer);

		// parse next instruction
		bool MoveNext() override;

		// read current instruction type
		InstructionType ReadInstructionType() override;

		// read current instruction data
		const char* ReadStringData() override;


	private:

		// general parser states
		enum class State {
			Program,
			Statement,
			BlockOrObject,
			BlockOrObject2ndToken,
			BlockTemp, 
			Block,
			ObjectTemp,
			Expression,
			ExpressionPopUnary,
			KeyValue,
			KeyValueColon,
			KeyValueComma,
			CallList,
			CallListComma,
			IdList,
			IdListComma,
			FunctionEnd,
			FunctionBegin,
			FunctionEndParameters,
			LocalEnd,
			BreakStatement,
			ContinueStatement,
			ReturnStatement,
			ReturnStatementWithExpression,
			IfBeginParam,
			IfEndParam,
			IfElse,
			IfElseEnd,
			LoopBegin,
			LoopEnd0,
			LoopParamBegin,
			LoopParamComma,
			LoopParamSecond,
			LoopEnd1,
			LoopParamSecondComma,
			LoopParamThird,
			LoopEnd2,
			LoopParamThirdEnd,
			LoopEnd3,
		};

		// used for parsing expressions
		enum class Op
		{
			// state
			Term,
			Expression,
			Paranthesis,
			Braces,
			Bracket,
			FunctionCall,
			// unary ops
			UnaryPlus,
			UnaryMinus,
			// binary ops
			Add,
			Subtract,
			Multiply,
			Divide,
			Assign,
			// comparison
			Equals,
			NotEquals,
			Greater,
			GreaterOrEqual,
			Less,
			LessOrEqual
		};

		bool ParseProgram();
		bool ParseStatement();
		bool ParseBlockOrObject();
		bool ParseBlockOrObject2ndToken();
		bool ParseBlockTemp();
		bool ParseBlock();
		bool ParseExpression();
		bool ParseExpressionPopUnary();
		bool ParseKeyValue();
		bool ParseKeyValueColon();
		bool ParseKeyValueComma();
		bool ParseCallList();
		bool ParseCallListComma();
		bool ParseIdList();
		bool ParseIdListComma();
		bool ParseFunctionEnd();
		bool ParseFunctionBegin();
		bool ParseFunctionEndParameters();
		bool ParseLocalEnd();
		bool ParseBreakStatement();
		bool ParseContinueStatement();
		bool ParseReturnStatement();
		bool ParseReturnStatementWithExpression();
		bool ParseIfBeginParam();
		bool ParseIfEndParam();
		bool ParseIfElse();
		bool ParseIfElseEnd();
		bool ParseLoopBegin();
		bool ParseLoopEnd0();
		bool ParseLoopParamBegin();
		bool ParseLoopParamComma();
		bool ParseLoopParamSecond();
		bool ParseLoopParamSecondComma();
		bool ParseLoopEnd1();
		bool ParseLoopParamThird();
		bool ParseLoopEnd2();
		bool ParseLoopParamThirdEnd();
		bool ParseLoopEnd3();

		InstructionType OpToInstructionType(Op top) const;
		InstructionType TokenToAtom(Token token);
		Op TokenToBinaryOp(Token token);
		Op TokenToUnaryOp(Token token);

		// returns true if operator has one param
		bool OpIsUnary(Op op);

		// all op types generated by the lexer
		static constexpr int OpPrecedence(Op op) noexcept;

		// returns if op is right associative, otherwise false
		static constexpr bool OpIsRightAssociative(Op op) noexcept;

		InstructionType instruction;
		std::string instructionData;
		Lexer& lexer;
		std::stack<State> state;
		std::stack<Op> opStack;
		Token tempToken;
		std::string tempBuffer;
		bool expressionPrevAtom;
		bool expressionPrevOp;
			
		ParserException ParseError(); // create default parser error
		ParserException ParseError(const char* message); // parser error with reason message


	};

	constexpr int Parser::OpPrecedence(Op op) noexcept
	{
		switch (op)
		{
		case Op::Assign:
			return 4;
		case Op::Equals:
		case Op::NotEquals:
			return 5;
		case Op::GreaterOrEqual:
		case Op::Greater:
		case Op::Less:
		case Op::LessOrEqual:
			return 6;
		case Op::Add:
		case Op::Subtract:
			return 7;
		case Op::Multiply:
		case Op::Divide:
			return 8;
		case Op::UnaryMinus:
		case Op::UnaryPlus:
			return 18;
		default:
			return 0;
		}
	}

	constexpr bool Parser::OpIsRightAssociative(Op op) noexcept
	{
		switch (op)
		{
		case Op::Assign:
			return true;
		default:
			return false;
		}
	}
}